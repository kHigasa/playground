## chap01

- Cは自由な言語だ。*C makes it easy to shoot yourself in the foot.*

## chap02

- stack
- char型の変数は1byteのサイズ(cf.int: 4byte)、1文字に1byteのメモリが必要。また、C言語は文字列型を持たない。よって配列に格納。配列の最後に *\0* を格納することで明示的に文字列であることを示す。
- *''* で文字を数値として扱ってくれる。
- *""* でくくられた文字列はconstな読み込み領域に確保される。
- *static*に変数を宣言することで、stackではないメモリ領域に保存できる。
- *const*指定子の再代入はコンパイラがエラーを吐いてくれる🤮

## chap03

- 条件式も値を持つ。 `true => value:1, false => value:0`
- ビット演算で、 `IPアドレス & サブネットマスク = ネットワークアドレス`
- 論理積 *&* 、論理和 *|* 、排他的論理和 *^* 、論理否定 *~*
- `n回<< => value:2^n, n回>>=> value:(1/2)^n`
- ビット演算は整数系のデータ型にのみ適用する。例えばfloatはメモリを符号部・指数部・仮数部と分けて格納しているため、1が単純な2進数の1とはならない。
- 右シフトには最上位ビットの扱いにより、算術右シフトと論理右シフトがある。Cはコンパイラに依存するが、プログラマーが選択できる言語もある。そのため、最上位ビットが特別な意味を持たない *unsigned* のデータ型に使うのが安全。

## chap04

- `switch`😋
- 比較には定数式（ラベル）しか使えない。
- 上から条件に当てはまるラベルを見つけていくので *break*必須
- あえてbreak文を使わない時、**//FALLTHRU**
- break文まで到達しない場合、**//NOT REACHED**
- `goto`🤢

## chap05

- システムで標準的に利用する関数はヘッダファイルの中にプロトタイプ宣言がある。`int printf(const char *restrict format, ...);`
- 「通常、変数はスタックに確保される」`func.c`においてスタックは、スタートアップルーチンへの戻りアドレス→変数num_1のためのメモリアドレス→変数num_2のためのメモリアドレス→変数answerのためのメモリアドレス→main()関数へのメモリアドレス→変数aのためのメモリアドレス→変数bのためのメモリアドレス。関数は呼び出すたびに呼び出し元の関数のアドレスをスタックに積み、実行終了後はスタックから呼び出し元関数に戻る。
- ***プロトタイプ宣言を記述する。***
- ***コンパイラには警告を多く出すオプション(`--Wall`など)を与える。***
- `fgets()`関数はファイル（ストリーム）から文字列を読むための関数。（C言語が生まれ育ったUnixでは様々なデバイスをファイルとして抽象化するという考えがあるため`stdin`を指定できる）
- コレクションクラスはない。

## chap06

- `include`はプリプロセス時にテキストに置換されている。
- 定義済みdefine`gcc -dM -xc -E /dev/null`
- マクロ関数はただのテキスト置換（関数にするまでもない小さなものを扱う時利用）∴データ型を意識しない
- マクロ関数は制御文も使用可

## chap07
- 配列：同データ型の変数がメモリ上の連続した領域に並んでいる
- どちらも配列の先頭アドレスを指している `one_string` `&one_string[0]`
- 配列とポインタ🤩
- 糖衣構文(syntax sugar)☺️
- が、似て非なるもの ⭕️`ptr = array` ❌`array = ptr`
- ぬるぽ 定石：`char *str = NULL; process; if(str == NULL) {A //process failure} else {B //process success}`
- voidポインタでどんなデータ型のポインタでも保持できる

## chap08
- アラインメントのためにパディングを入れている
- 共用体：メンバ変数間でメモリ領域を共有している構造体

## chap09
😕

## chap10
- 自動変数はスタック上に確保され関数が呼び出されたときに作られる。そのためサイズはコードに指定しただけしか確保されない。メモリを動的に確保するためには専用の関数を使う。OSが管理するヒープ領域からメモリを取得し、使用後に解放する。
- **Copy-On-Write**🙃
- *memory leak*

## chap11
- fileのclose処理を行うことでbufferingされている情報を実際のディスクに保存するフラッシュという動作が行われる。
- *resource leak*
- `argc`:引数の数、`*argv`:引数の文字列 (自身のプログラム名が先頭要素に入る)

## chap12
- [FreeBSD](https://svnweb.freebsd.org/)
