## chap01

- Cは自由な言語だ。*C makes it easy to shoot yourself in the foot.*

## chap02

- stack
- char型の変数は1byteのサイズ(cf.int: 4byte)、1文字に1byteのメモリが必要。また、C言語は文字列型を持たない。よって配列に格納。配列の最後に *\0* を格納することで明示的に文字列であることを示す。
- *''* で文字を数値として扱ってくれる。
- *""* でくくられた文字列はconstな読み込み領域に確保される。
- *static*に変数を宣言することで、stackではないメモリ領域に保存できる。
- *const*指定子の再代入はコンパイラがエラーを吐いてくれる🤮

## chap03

- 条件式も値を持つ。 `true => value:1, false => value:0`
- ビット演算で、 `IPアドレス & サブネットマスク = ネットワークアドレス`
- 論理積 *&* 、論理和 *|* 、排他的論理和 *^* 、論理否定 *~*
- `n回<< => value:2^n, n回>>=> value:(1/2)^n`
- ビット演算は整数系のデータ型にのみ適用する。例えばfloatはメモリを符号部・指数部・仮数部と分けて格納しているため、1が単純な2進数の1とはならない。
- 右シフトには最上位ビットの扱いにより、算術右シフトと論理右シフトがある。Cはコンパイラに依存するが、プログラマーが選択できる言語もある。そのため、最上位ビットが特別な意味を持たない *unsigned* のデータ型に使うのが安全。

## chap04

- `switch`😋
- 比較には定数式（ラベル）しか使えない。
- 上から条件に当てはまるラベルを見つけていくので *break*必須
- あえてbreak文を使わない時、**//FALLTHRU**
- break文まで到達しない場合、**//NOT REACHED**
- `goto`🤢

## chap05

- システムで標準的に利用する関数はヘッダファイルの中にプロトタイプ宣言がある。`int printf(const char *restrict format, ...);`
- 「通常、変数はスタックに確保される」`func.c`においてスタックは、スタートアップルーチンへの戻りアドレス→変数num_1のためのメモリアドレス→変数num_2のためのメモリアドレス→変数answerのためのメモリアドレス→main()関数へのメモリアドレス→変数aのためのメモリアドレス→変数bのためのメモリアドレス。関数は呼び出すたびに呼び出し元の関数のアドレスをスタックに積み、実行終了後はスタックから呼び出し元関数に戻る。
- ***プロトタイプ宣言を記述する。***
- ***コンパイラには警告を多く出すオプション(`--Wall`など)を与える。***
- `fgets()`関数はファイル（ストリーム）から文字列を読むための関数。（C言語が生まれ育ったUnixでは様々なデバイスをファイルとして抽象化するという考えがあるため`stdin`を指定できる）
- コレクションクラスはない。

## chap06

- `include`はプリプロセス時にテキストに置換されている。
- 定義済みdefine`gcc -dM -xc -E /dev/null`
- マクロ関数はただのテキスト置換（関数にするまでもない小さなものを扱う時利用）∴データ型を意識しない
- マクロ関数は制御文も使用可

## chap07
- 配列：同データ型の変数がメモリ上の連続した領域に並んでいる
- どちらも配列の先頭アドレスを指している `one_string` `&one_string[0]`
- 配列とポインタ🤩
- 糖衣構文(syntax sugar)☺️
- が、似て非なるもの ⭕️`ptr = array` ❌`array = ptr`
