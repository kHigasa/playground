# compile

`g++ -o <output_file_name> <input_file>`

## chap04

- `std::cout`オブジェクトは左シフト演算子`<<`を出力演算子としてオーバーロードしている。

- 文字型のデータは単一引用符、文字列は二重引用符。

- ワイド文字 `wchar_t wide; wide = L'Ω'`

## chap05

- メンバ関数`at`で文字列にアクセス。

## chap06

## chap07

```cpp
/********************************************************
 * guess -- a simple guessing game			*
 *							*
 * Usage:						*
 *	guess						*
 *							*
 *	A random number is chosen between 1 and 100.	*
 * 	The player is given a set of bounds and 	*
 *	must choose a number between them.		*
 *      If the player chooses the correct number he wins*
 *	Otherwise the bounds are adjusted to reflect	*
 *	the players guess and the game continues	*
 *							*
 * Restrictions:					*
 *	The random number is generated by the statment	*
 *	rand() % 100.  Because rand() returns a number	*
 *	0 <= rand() <= maxint  this slightly favors	*
 *	the lower numbers.				*
 ********************************************************/
#include <iostream>
#include <cstdlib>

int   number_to_guess;	// random number to be guessed
int   low_limit;	// current lower limit of player's range
int   high_limit;	// current upper limit of player's range
int   guess_count;	// number of times player guessed
int   player_number;	// number gotten from the player

int main()
{
    while (true) {
	/*
	 * Not a pure random number, see restrictions
	 */
	number_to_guess = rand() % 100 + 1;

	// Initialize variables for loop
	low_limit = 0;
	high_limit = 100;
	guess_count = 0;

	while (true) {
	    // tell user what the bounds are and get his guess
	    std::cout << "Bounds " << low_limit << " - " << high_limit << '\n';
	    std::cout << "Value[" << guess_count << "]? ";

	    ++guess_count;

	    std::cin >> player_number;

	    // did he guess right?
	    if (player_number == number_to_guess)
		break;

	    // adjust bounds for next guess
	    if (player_number < number_to_guess)
		low_limit = player_number;
	    else
		high_limit = player_number;

	}
	std::cout << "Bingo\n";
    }
    return (0);
}

```

## chap08

## chap09

- すべての変数はスコープと記憶クラスの２つの属性を持つ。

- voidリストは空のリストが他の目的に使用されていたために生じた構文上の問題を解決するためにCに導入された。

- 関数のオーバーロードには引数リストによって関数の区別がつくように定義しなければならない。

- callback funcなどのため、使用しない引数を関数に渡す場合もある。

- inline関数：関数がとても小さいものであることをコンパイラに示し、関数呼び出しを生成するのではなく、関数本体をコードストリームに入れてオーバーヘッドを排除するようにする。

## chap10

- プリプロセッサコマンドは＃で始まりEOLで終わる。

## chap11

- シフトは積算や除算より高速。

## chap12

## chap13

- classによりデータの保持だけでなく、データ操作の一連の関数とアクセス保護を追加する。

- 代入の変換をさけるためexplicitにコンストラクタを宣言する。

## chap14

- `friend`修飾子を用い宣言元の`private`データにアクセスする。

- 定数メンバの初期化に注意。

- staticメンバはオブジェクトに属しているのではなく、クラスに属している。

## chap15

- `*const`：定数ポインタ

## chap16
