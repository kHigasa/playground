## chap01

*OCaml is strongly static typed language.*
弱い型付けのCなどとは違い、静的型検査によってプログラムの安全性が保証される。

## chap02

- OCamlの式の実行について：**式を評価してその値を求めること**

- 型について：**式を良い式と悪い式に分類する基準であり、良い式につけられる属性**

- 対話式コンパイラ終了のディレクティブ：`#quit;;`

- X→Yへデータ型を変換するとき：`Y_of_X`

- ***変数束縛：variable binding***

## chap03

- *George Boole*

- 一般的な式の形：`let var = expr1 in expr2` expr1を評価、変数にその値を束縛し、expr2を評価しその値を求める。

- 変数について：
  - 静的有効範囲を持つ(static | lexical scope)。
  - トップレベル環境 == 大域環境
  - 環境では末尾に束縛が追加されていき、同名変数は再定義される。
  - 変数参照は環境を下から順に探していく。
  - 関数に関して、仮引数に実引数が束縛されるのは、関数が定義された時点での環境。❌実行時

- 組(tuple)について：**値に順序をつけて並べたもの** 第一要素、。。。

- 組に対する基本操作：**pattern matching**

- 本来一引数であるが、組によって複数引数を模倣する。

- 式の評価戦略：
  - 🔮**値呼び(call-by-value)**：関数適用の際はまず引数を評価する
  - **名前呼び(call-by-name)**：引数は使うまで評価しない-外側の関数適用から順に引数を式のままパラメータに置換する
  - **必要呼び(call-by-need)**：引数は使うまで評価しない-外側の関数適用から順に引数を式のままパラメータに置換する＋一度評価した式は結果を覚えておいて二度評価しない(ex/Haskell, Miranda)

- 末尾再帰関数は再帰の深さに関わらずメモリの使用量が固定量であるような効率的な実行が可能になる

- `let f pat = expr` == `let f = fun pat -> expr` // 関数を構成し、命名している(第二式の右辺は匿名関数の宣言)

- *Haskell Curry*

- **Currying**について：基本的なアイデアは「引数xとyを受け取りeを評価する関数」を「xを受け取ると「yを受け取ってeを評価する関数」を返す関数」として表現すること

- 関数適用は左結合する：`f x y z == (((f x) y) z)`

- 型構築子は右結合する：`t1 -> t2 -> t3 -> t4 == t1 -> (t2 -> (t3 -> t4))`

## chap04

- **多相性 polymorphism**：様々な型を持つという性質->型だけ異なるような定義を省けるため、プログラムの再利用性が高まる。

- 型の抽象化は自動的に行われ、型スキーム`'a * 'b -> 'a = <fun>`で表現される。型推論の過程で、適当に型スキームの具体化が行われる。

- パラメトリック多相：関数の型情報の一部をパラメータ化することによって発生する多相性
  - 関数が引数に関する情報の一部のみで計算を行うことから生じている
  - 型変数は関数が一切操作しない部分を抽象的に表現していると考えられる（関数は型変数を使わないんだなとわかる）

- 比較演算子は形式はパラメトリック多相的であるが動作はアドホック多相的である。

- 型推論は式と型環境からわからない型については、適宜未知の変数を使いながら、式の型と未知の変数に関する方程式を立てて、それを解くことで行われる。

- `let f = fun x -> (x, x);;`の推論の際、右辺の型は`'_a -> '_a * '_a`となる「fは任意の型'_aに対して'_a -> '_a * '_a型を持つ」。これが一般化により、「fは型スキーム'a -> 'a * 'a」となる。

- **let多相**：多相的に使える変数はletを使って宣言されたものに限られる。

- 型推論の完全性について：
  - 変数宣言に":int"などの型の注釈をつけても型がつくのであれば、省略しても必ず型推論は成功する（完全性）。
  - 型推論は与えられた式と型環境の下で最も一般的な型を常に推論する。

- 定義の右辺がそのまま値であれば型変数を一般化して良い（値とは関数の宣言、定数など計算を必要としないもの ❌関数適用）

- OCamlでfun式と関数適用の組み合わせのみで表現できる関数はすべてSとKを関数適用で組み合わせることによって表現される。

## chap05

- listの定義は再帰的。

- 要素を並べたlist表現は単に`::`infix operatorを用いた略記法。

- **matching clause**：`match expr0 with pat1 -> expr1 | ... | patn -> exprn`

## chap06
