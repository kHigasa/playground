# chap01

*OCaml is strongly static typed language.*
弱い型付けのCなどとは違い、静的型検査によってプログラムの安全性が保証される。

## chap02

- OCamlの式の実行について：**式を評価してその値を求めること**

- 型について：**式を良い式と悪い式に分類する基準であり、良い式につけられる属性**

- 対話式コンパイラ終了のディレクティブ：`#quit;;`

- X→Yへデータ型を変換するとき：`Y_of_X`

- ***変数束縛：variable binding***

## chap03

- *George Boole*

- 一般的な式の形：`let var = expr1 in expr2` expr1を評価、変数にその値を束縛し、expr2を評価しその値を求める。

- 変数について：
  - 静的有効範囲を持つ(static | lexical scope)。
  - トップレベル環境 == 大域環境
  - 環境では末尾に束縛が追加されていき、同名変数は再定義される。
  - 変数参照は環境を下から順に探していく。
  - 関数に関して、仮引数に実引数が束縛されるのは、関数が定義された時点での環境。❌実行時

- 組(tuple)について：**値に順序をつけて並べたもの** 第一要素、。。。

- 組に対する基本操作：**pattern matching**

- 本来一引数であるが、組によって複数引数を模倣する。

- 式の評価戦略：
  - 🔮**値呼び(call-by-value)**：関数適用の際はまず引数を評価する
  - **名前呼び(call-by-name)**：引数は使うまで評価しない-外側の関数適用から順に引数を式のままパラメータに置換する
  - **必要呼び(call-by-need)**：引数は使うまで評価しない-外側の関数適用から順に引数を式のままパラメータに置換する＋一度評価した式は結果を覚えておいて二度評価しない(ex/Haskell, Miranda)

- 末尾再帰関数は再帰の深さに関わらずメモリの使用量が固定量であるような効率的な実行が可能になる

- `let f pat = expr` == `let f = fun pat -> expr` // 関数を構成し、命名している(第二式の右辺は匿名関数の宣言)

- *Haskell Curry*

- **Currying**について：基本的なアイデアは「引数xとyを受け取りeを評価する関数」を「xを受け取ると「yを受け取ってeを評価する関数」を返す関数」として表現すること

- 関数適用は左結合する：`f x y z == (((f x) y) z)`

- 型構築子は右結合する：`t1 -> t2 -> t3 -> t4 == t1 -> (t2 -> (t3 -> t4))`

## chap04

- **多相性 polymorphism**：様々な型を持つという性質->型だけ異なるような定義を省けるため、プログラムの再利用性が高まる。

- 型の抽象化は自動的に行われ、型スキーム`'a * 'b -> 'a = <fun>`で表現される。型推論の過程で、適当に型スキームの具体化が行われる。

- パラメトリック多相：関数の型情報の一部をパラメータ化することによって発生する多相性
  - 関数が引数に関する情報の一部のみで計算を行うことから生じている
  - 型変数は関数が一切操作しない部分を抽象的に表現していると考えられる（関数は型変数を使わないんだなとわかる）

- 比較演算子は形式はパラメトリック多相的であるが動作はアドホック多相的である。
