## chap01

*OCaml is strongly static typed language.*
弱い型付けのCなどとは違い、静的型検査によってプログラムの安全性が保証される。

## chap02

- OCamlの式の実行について：**式を評価してその値を求めること**

- 型について：**式を良い式と悪い式に分類する基準であり、良い式につけられる属性**

- 対話式コンパイラ終了のディレクティブ：`#quit;;`

- X→Yへデータ型を変換するとき：`Y_of_X`

- ***変数束縛：variable binding***

## chap03

- *George Boole*

- 一般的な式の形：`let var = expr1 in expr2` expr1を評価、変数にその値を束縛し、expr2を評価しその値を求める。

- 変数について：
  - 静的有効範囲を持つ(static | lexical scope)。
  - トップレベル環境 == 大域環境
  - 環境では末尾に束縛が追加されていき、同名変数は再定義される。
  - 変数参照は環境を下から順に探していく。
  - 関数に関して、仮引数に実引数が束縛されるのは、関数が定義された時点での環境。❌実行時

- 組(tuple)について：**値に順序をつけて並べたもの** 第一要素、。。。

- 組に対する基本操作：**pattern matching**

- 本来一引数であるが、組によって複数引数を模倣する。

- 式の評価戦略：
  - 🔮**値呼び(call-by-value)**：関数適用の際はまず引数を評価する
  - **名前呼び(call-by-name)**：引数は使うまで評価しない-外側の関数適用から順に引数を式のままパラメータに置換する
  - **必要呼び(call-by-need)**：引数は使うまで評価しない-外側の関数適用から順に引数を式のままパラメータに置換する＋一度評価した式は結果を覚えておいて二度評価しない(ex/Haskell, Miranda)

- 末尾再帰関数は再帰の深さに関わらずメモリの使用量が固定量であるような効率的な実行が可能になる

- `let f pat = expr` == `let f = fun pat -> expr` // 関数を構成し、命名している(第二式の右辺は匿名関数の宣言)

- *Haskell Curry*

- **Currying**について：基本的なアイデアは「引数xとyを受け取りeを評価する関数」を「xを受け取ると「yを受け取ってeを評価する関数」を返す関数」として表現すること

- 関数適用は左結合する：`f x y z == (((f x) y) z)`

- 型構築子は右結合する：`t1 -> t2 -> t3 -> t4 == t1 -> (t2 -> (t3 -> t4))`

## chap04

- **多相性 polymorphism**：様々な型を持つという性質->型だけ異なるような定義を省けるため、プログラムの再利用性が高まる。

- 型の抽象化は自動的に行われ、型スキーム`'a * 'b -> 'a = <fun>`で表現される。型推論の過程で、適当に型スキームの具体化が行われる。

- パラメトリック多相：関数の型情報の一部をパラメータ化することによって発生する多相性
  - 関数が引数に関する情報の一部のみで計算を行うことから生じている
  - 型変数は関数が一切操作しない部分を抽象的に表現していると考えられる（関数は型変数を使わないんだなとわかる）

- 比較演算子は形式はパラメトリック多相的であるが動作はアドホック多相的である。

- 型推論は式と型環境からわからない型については、適宜未知の変数を使いながら、式の型と未知の変数に関する方程式を立てて、それを解くことで行われる。

- `let f = fun x -> (x, x);;`の推論の際、右辺の型は`'_a -> '_a * '_a`となる「fは任意の型'_aに対して'_a -> '_a * '_a型を持つ」。これが一般化により、「fは型スキーム'a -> 'a * 'a」となる。

- **let多相**：多相的に使える変数はletを使って宣言されたものに限られる。

- 型推論の完全性について：
  - 変数宣言に":int"などの型の注釈をつけても型がつくのであれば、省略しても必ず型推論は成功する（完全性）。
  - 型推論は与えられた式と型環境の下で最も一般的な型を常に推論する。

- 定義の右辺がそのまま値であれば型変数を一般化して良い（値とは関数の宣言、定数など計算を必要としないもの ❌関数適用）

- OCamlでfun式と関数適用の組み合わせのみで表現できる関数はすべてSとKを関数適用で組み合わせることによって表現される。

## chap05

- listの定義は再帰的。

- 要素を並べたlist表現は単に`::`infix operatorを用いた略記法。

- **matching clause**：`match expr0 with pat1 -> expr1 | ... | patn -> exprn`

## chap06

- フィールド名はその型に関連付けられているため、同じフィールド名を持つ別の型を宣言すると、変数の再宣言と同様、古いフィールド名の宣言が隠蔽されてしまう。(コンストラクタも同様)

- *;* はセパレーターとして考えよう。

- オプション型を返す関数は正常に計算が行われた場合に`Some v`という形でvを返し、答えがない場合には`None`を返す。

- ヴァリアントは基本的には場合分けを表すデータ構造

## chap07

- 例外コンストラクタ：例外の名前はexn型のコンストラクタ

## chap08

- 副作用*side effect*：端末への出力のような実行に伴って発生する、値の計算以外のなにか

- 書き換え可能なデータ構造を構成する式が評価されると、その度に値がメモリ上に記録される。

- 物理的等価性*physical equality*：アドレスでの比較 ==, !=

- 構造的等価性*structual equality*：値としての比較 =

- 配列：同じ種類の値の集合を表すデータ、長さは固定長でどの要素にも直接アクセスできる

- letの右辺の型にはそれが値でない場合多相的に使用できないことがある、という制限がある。書き換えによって全くナンセンスな操作が行われないよう、そもそも参照や書き換え可能なデータを生成しない値を必要とする。レコード式はすべてのフィールドがimmutableであれば値である。

- 逐次実行：expr1から順に評価を行い、exprnの値を全体の値とする。

- 条件分岐：then節がunit型の式である時else節を省略できる。

- ファイル入出力はチャネルを介して行われる。

- チャネル出力の際、bufferingのため時折flushする。

- 標準入出力や標準エラー出力もチャネル。

## chap09

- フォーマット文字列定数には文字列の値によって異なる特別な型が与えられる。

- 四則演算を含む多くの関数は`Pervasives`という起動時からopenされているモジュールで定義されている。`Pervasives.abs`

- **signature**：`sig``end`で囲まれた部分全体。モジュール全体の型のようなもの。

- \<abstr>：定義内容の隠蔽された型の値

## chap10

- batch compiler：`ocamlc` -> gen byte code `ocamlopt` -> gen native code

## chap11

- **functor適用**：`functor_name ( module_expr )`

- ファンクタは返り値の型が引数の値に依存する依存型である。ファンクタが適用されたときに生成されるモジュールのシグネチャが引数として与えられるストラクチャそのものに依存する。

## chap12

- オブジェクトの状態は常に外部から隠蔽されていて、全てメソッドカラの実操作する。

- **クラス＝型ではない。**

- **..**：列変数。メソッド名とその型の列に具体化でき、パラメトリック多相の一種とも考えられる。
